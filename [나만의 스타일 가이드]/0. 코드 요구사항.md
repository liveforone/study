## 코드 요구사항
* 해당 문서는 프로젝트 코드의 요구사항을 정리한 문서이다.
* 해당 프로젝트는 기본적으로 스타일가이드를 베이스로 하고 있다.

## 비동기 처리
* 동시성이 발생하는 경우나, 생성(insert) 작업 이외에는 가능한 비동기로 처리한다.
* 또한 리턴값이 반드시 없어야한다.(void)
* 주로 서비스 계층, 카프카 컨슈머/프로듀서에서 사용한다.
* 순서가 중요한 경우, 주로 delete시에는 순서를 따져보고, 순서가 존재한다면 비동기를 사용하지 않는다.
* 또한 서비스 계층 테스트 시에는 비동기 어노테이션을 잠깐 주석처리하고 테스트를 확인한다.

## 배치처리 시 벌크연산
* 배치처리를 반드시 벌크연산을 사용해야한다.
* 다량의 데이터를 더티체킹하면 장애가 유발될 수 있고, 성능이 보장되지 않기때문에 반드시 벌크연산을 사용한다.

## 매퍼 사용
* 주로 단건의 엔티티를 response dto로 만들때 사용된다.
* 매퍼는 서비스 계층에서만 사용한다. 절대로 다른계층에서 엔티티를 직접 받아 사용하지 않는다.

## 컨트롤러에서 if문 남발이 아닌 커스텀예외를 이용해 controller advice로 처리하라
* 컨트롤러에서 기존의 gate-way 스타일을 사용하게되면 if - return이 반복된다.
* 이러한 코드는 가독성은 좋지만 깔끔하진 않다.
* 이를 더욱 깔끔하게 만들기 위해서 validator에서 커스텀예외를 터뜨리고,
* 적절한 rest response를 객체에 담아서 controller advice에서 처리하도록 한다.
* 이렇게 처리하면 클라이언트에게 적절한 response와 status를 리턴하게되어서 아주 깔끔한 처리가된다.
* 또한 컨트롤러에서도 validator를 선언하고 끝나기때문에 선언형 코드가 만들어져서 깔끔한 코드가 만들어진다.

## 더티체킹 적극 활용
* 선언형 스타일을 적극활용가능하고, 깔끔한 서비스 계층과
* 엔티티에서 도메인 로직을 처리하는 도메인 모델 패턴을 사용하기 위해 더티체킹을 적극활용하라.

## 대량의 데이터 조회시에는 dto projection을 사용하라
* 리스트나, 페이징을 할때에는 가져오는 데이터의 양이 많다.
* 모든 필드를 다 가져온 후에 매퍼를 이용해 response dto로 변환하는 과정은
* 대량의 데이터 조회시에 성능을 악화시킨다.
* 따라서 대량의 데이터를 조회할때에는 필요한 데이터만 가져오는
* dto projection을 사용해서 가져온다.
* 이를 통해서 조회 성능을 높일 수 있다.

## 검색쿼리는 like% 쿼리를 사용하라
* contains와 %like는 인덱스를 타지 않는 풀스캔을 한다.
* 항상 장애는 대량의 데이터 조회시에 발생한다.
* 이러한 과정에서 풀스캔 까지 해버리면 장애가 발생할 확률이 증가한다.
* 따라서 검색시에는 like%를 사용하여 인덱스를 반드시 탈 수 있도록 하여 성능을 높인다.
* query dsl 에서는 startsWith() 메서드를 사용하면된다.

## validator를 위한 단건 조회 쿼리를 만들어라
* validator에서는 데이터를 검증하는 일을 한다.
* 대부분의 경우 데이터를 조회해야한다.
* 모든 필드를 가져오기보다, id를 가져오거나, 필요한 필드 하나를 가져오는 쿼리를 이용하면 성능을 높일 수 있다.
* 특히나 null check나 중복 체크 등에서는 id를 가져오는 것이 좋다.
* 필드가 필요한 경우 해당 필드만은 가져와서 비교/검증한다.

## 리파지토리 유틸클래스를 만들어라
* 페이징이나, dto projection, 복잡한 조건등을 처리하는데는 유틸클래스가 제격이다.
* 유틸클래승에서는 큐클래스가 중복되는 일이 발생할 수 있다.
* 따라서 [repository 유틸 클래스에서 Q클래스 중복](https://github.com/liveforone/middle/blob/master/Documents/REPO_UTIL_DUPLICATE_QCLASS.md)을 참조하여 해결하라.

## 동적쿼리를 적극 활용하라
* 다중 검색 조건 등에서는 누락되는 검색어 등이 존재한다.
* 이런 경우가 아니더라도 복잡하고, 누락가능한 쿼리를 만들기에는 동적쿼리가 좋다.
* 하나의 쿼리 메서드에서 다양한 조건을 처리할 수 있기에, 동적쿼리를 적극활용하라.

## 상수 요구사항
* 상수를 담는 클래스는 fianl로 선언하라.
* 또한 생성자 선언이 불가능하도록 기본 생성자를 private으로 선언하라.
* 이러한 상수가 전역으로 사용되는 것이 아닌 특정 클래스에 종속된것이라면
* static import를 이용해 깔끔하게 처리하라.
* 상수 클래스의 네이밍시 Constant를 붙이지 않는다.(XxConstant 금지)

## spring validation 사용 유의 사항
* spring validation을 이용해 바인딩 값을 검증할때에는
* 반드시 @NotBlank로 문자에 관련한 모든 값에 대해 null을 체크할 수 있도록 한다.
* 또한 @Email이 붙은 값에도 notblank를 붙여서 null을 체크하라.
* 숫자 타입의 경우에는 @Positive나 @Negative 처럼 0을 제한하는 것이 좋다.

## @RequestParam에 기본값 설정하라
* reqeust param으로 받는 파라미터는 기본값에는 반드시 기본값을 설정하라.
* 문자의 경우 required=false를 선언하면 되고,
* 숫자의 경우 defaultValue = "값"을 선언하면된다.
* 이를 통해 클라이언트에서 요청하는 값을 유연하게 반응 할 수 있도록 한다.

## provide controller
* 다른 서비스에 요청을 처리하는 provide controller는 특정 서비스에 종속되게 만들지 않는다.
* 하나의 provide controller에서 다양한 서비스의 요청을 처리한다.
